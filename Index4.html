<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Squid Game Doll 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-image: url('background.jpg');
            background-size: cover;
        }
        #startButton, #stopButton, #timer, #gameOver {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            font-size: 16px;
        }
        #stopButton, #gameOver {
            display: none;
        }
    </style>
</head>
<body>
    <button id="startButton">Start</button>
    <button id="stopButton">Stop</button>
    <div id="timer">Time left: 0:00</div>
    <div id="gameOver">Game Over</div>

    <!-- Load Three.js and GLTFLoader -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://unpkg.com/three@0.134.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // Set up the Three.js scene
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(0, 1, 1);
        scene.add(directionalLight);

        // Load the Squid Game doll model
        const loader = new THREE.GLTFLoader();
        let headBone, handBone;
        loader.load('model.glb', (gltf) => {
            const model = gltf.scene;
            scene.add(model);
            model.position.set(0, -1, 0); // Adjust position
            model.scale.set(1, 1, 1); // Adjust scale if needed

            // Find bones (names depend on your model)
            headBone = model.getObjectByName('Head') || model.children[0].skeleton.bones.find(b => b.name.includes('head') || b.name.includes('Head'));
            handBone = model.getObjectByName('Hand') || model.children[0].skeleton.bones.find(b => b.name.includes('hand') || b.name.includes('Hand'));

            // Add sunglasses
            const sunglasses = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.05, 0.01),
                new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            sunglasses.position.set(0, 0.05, 0.1);
            headBone.add(sunglasses);

            // Add laptop
            const laptop = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.01, 0.2),
                new THREE.MeshBasicMaterial({ color: 0x555555 })
            );
            laptop.position.set(0, 0.1, 0);
            handBone.add(laptop);
        });

        // Position the camera
        camera.position.z = 5;

        // Animation variables
        let targetHeadRotation = 0;
        let currentHeadRotation = 0;

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            if (headBone) {
                currentHeadRotation += (targetHeadRotation - currentHeadRotation) * 0.1;
                headBone.rotation.y = currentHeadRotation;
            }
            renderer.render(scene, camera);
        }
        animate();

        // Random head turning
        function scheduleHeadTurn() {
            const delay = Math.random() * 10000 + 5000; // 5-15 seconds
            setTimeout(() => {
                targetHeadRotation = Math.PI; // Turn head back
                setTimeout(() => {
                    targetHeadRotation = 0; // Turn head forward
                    scheduleHeadTurn();
                }, Math.random() * 3000 + 2000); // 2-5 seconds
            }, delay);
        }

        // Game logic
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const timerDisplay = document.getElementById('timer');
        const gameOverDisplay = document.getElementById('gameOver');
        let remainingSeconds = 0;
        let gameInterval;

        startButton.addEventListener('click', () => {
            const minutes = prompt('Enter timer in minutes:');
            if (minutes && !isNaN(minutes) && minutes > 0) {
                remainingSeconds = Math.floor(minutes * 60);
                updateTimerDisplay();
                startGame();
            } else {
                alert('Please enter a valid number of minutes.');
            }
        });

        stopButton.addEventListener('click', endGame);

        function startGame() {
            startButton.style.display = 'none';
            stopButton.style.display = 'block';
            gameOverDisplay.style.display = 'none';
            gameInterval = setInterval(() => {
                remainingSeconds--;
                updateTimerDisplay();
                if (remainingSeconds <= 0) endGame();
            }, 1000);
            scheduleHeadTurn();
        }

        function endGame() {
            clearInterval(gameInterval);
            gameOverDisplay.style.display = 'block';
            startButton.style.display = 'block';
            stopButton.style.display = 'none';
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(remainingSeconds / 60);
            const seconds = remainingSeconds % 60;
            timerDisplay.textContent = `Time left: ${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        // Resize handling
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>